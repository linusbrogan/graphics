Homogeneous coordinates
	x, y, z, and dummy 1
	Makes translation a matrix multiplication problem

In CS-367, we assumed the viewer was at the origin, looking at the +z-axis, with the +y-axis up.
Now we want an arbitrary perspective.
If the camera was moved to (2, 5, 1), for example, then we could equivalently move the world -(2, 5, 1) to get the same view.

Objects are built in "object space."
Each object gets some transformation to end up in the right place in the "world space."
We can also put a light and camera somewhere in world space.
To orient the camera, it also gets a "Center of Interest" and an "Up Point."

To bring the camera back to its default location:
- Translate the camera by the negative of its location.
- Rotate about the y-axis to bring the CoI onto the y-z plane.
- Rotate about the x-axis to bring the CoI onto the z-axis.
- Rotate about the z-axis to bring the Up Point onto the y-z plane.
The transformation matrix for this sequence is the "View Matrix".
Apply the view matrix to all objects to get the right picture from the default camera.

2022-02-01
View Matrix Computation, as Jeff suggests

Translate by -eye
Rotate CoI
	a = coi0 - eye0
	b = coi1 - eye1
	c = coi2 - eye2
	p = sqrt(a^2 + c^2)
	
	Rotate around z-axis
	C = cos = c / p
	S = sin = -a / p (negative angle)

	[ C 0 S 0 ] (a)   (0)
	[ 0 1 0 0 ] (b) = (b)
	[-S 0 C 0 ] (c)   (p)
	[ 0 0 0 1 ] (1)   (1)

	Rotate around x-axis
	Go from (0, b, p) to (0, 0, r)
	r = sqrt(b^2 + p^2)
	C = cos = p / r
	S = sin = b / r (positive angle)

	[ 1 0  0 0 ] (0)   (0)
	[ 0 C -S 0 ] (b) = (0)
	[ 0 S  C 0 ] (p)   (r)
	[ 0 0  0 1 ] (1)   (1)

	Send Up point through these transformations to get Up-bar
	Rotate around z-axis
	Up-bar = (x, y, z)
	h = sqrt(x^2 + y^2)
	C = cos = y / H
	S = sin = x / H (positive angle)

Parametrizing Shapes
Explicit form (y = f(x))
	Line: y = x
	Parabola: y = x^2
Implicit form (an equation, often with one side equalling 0 or 1)
	Circle: x^2 + y^2 = 1 or x^2 + y^2 - 1 = 0
	Hyperbola: x^2 - y^2 = 1
Parametric form (a function of another parameter)
	Circle: x(t) = cos(t), y(t) = sin(t)
	Line through (1, 2) and (5, 4):
		(x, y) = (1, 2) + t * [(5, 4) - (1, 2)]
	Hyperbola: (x, y) = (cosh(t), sin(t)) = (1 / 2) * (e^t + e^(-t), e^t - e^(-t))
3D Shapes
	Unit sphere:
		x^2 + y^2 + z^2 = 1
		Cylindrical coordinates
			(x, y, z) = (r * cos(u), v, r * sin(u)), r = sqrt(1 - v^2)), u in [0, tau), v in [-1,1] or similar
		Spherical coordinates
			(x, y, z) = r * (cos(t) * sin(p), sin(t) * sin(p), cos(p)), t in [0, tau), p in [0,pi]
			(x, y, z) = (cos(u) * cos(v), sin(v), sin(u) * cos(v)), u in [0,tau), v in [-pi / 2, pi / 2]
	Cylinder:
		(x, y, z) = (cos(u), v, sin(u))

Plotting 3D shapes
	Repeatedly pick random point in range and plot, a poor strategy.
	Plotting sphere with cylindrical coordinates should look more uniform than spherical.
Rendering
	Construct a point in object space, map through transformation matrix into world space and then view space, and then project onto the screen at z = 1.
	Sorting all points would take too much space and tiem, so do not save them.
	Save the z-value at every rendered pixel in a Z-buffer as big as the window.
	Render in reverse order of z, only re-rendering a pixel if the new z-value is closer than what is saved in the Z-buffer.

Projection
	Half angle: h
	Half screen height: H = tan(h)
	(x', y') = (x, y) / z
Transform onto computer screen
	For visible points (x', y' in [-H, H]), shift by (H, H) to have origin at bottom left.
	Scale by window size / (2 * H).
	Round to nearest pixel value, in [0, window size).
